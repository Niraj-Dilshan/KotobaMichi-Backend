name: Deploy Production

on:
  workflow_run:
    workflows: ['Build and Publish Docker Image']
    types: [completed]
  workflow_dispatch:

permissions:
  contents: read
  packages: read

concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  deploy:
    # Proceed if manual dispatch OR upstream publish workflow succeeded on 'production' branch
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.head_branch == 'production')
    runs-on:
      - serverone
      - self-hosted
    timeout-minutes: 25

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create .env for production
        id: write-env
        shell: bash
        env:
          # Secrets (configure in repository or organization settings)

          POSTGRES_DB_SECRET: ${{ secrets.PROD_POSTGRES_DB }}
          POSTGRES_USER_SECRET: ${{ secrets.PROD_POSTGRES_USER }}
          POSTGRES_PASSWORD_SECRET: ${{ secrets.PROD_POSTGRES_PASSWORD }}
          DATABASE_URL_SECRET: ${{ secrets.PROD_DATABASE_URL }}
          JWT_SECRET_SECRET: ${{ secrets.PROD_JWT_SECRET }}
          JWT_EXPIRES_IN_SECRET: ${{ secrets.PROD_JWT_EXPIRES_IN }}
          ACCESS_TOKEN_EXPIRES_IN_SECRET: ${{ secrets.PROD_ACCESS_TOKEN_EXPIRES_IN }}
          REFRESH_TOKEN_EXPIRES_IN_SECRET: ${{ secrets.PROD_REFRESH_TOKEN_EXPIRES_IN }}
          COOKIE_SECURE_SECRET: ${{ secrets.PROD_COOKIE_SECURE }}
          COOKIE_SAMESITE_SECRET: ${{ secrets.PROD_COOKIE_SAMESITE }}
          COOKIE_SECRET_SECRET: ${{ secrets.PROD_COOKIE_SECRET }}
          CORS_ORIGIN_SECRET: ${{ secrets.PROD_CORS_ORIGIN }}
          APP_URL_SECRET: ${{ secrets.PROD_APP_URL }}
          # SMTP secrets (optional)
          SMTP_HOST_SECRET: ${{ secrets.PROD_SMTP_HOST }}
          SMTP_PORT_SECRET: ${{ secrets.PROD_SMTP_PORT }}
          SMTP_SECURE_SECRET: ${{ secrets.PROD_SMTP_SECURE }}
          SMTP_USER_SECRET: ${{ secrets.PROD_SMTP_USER }}
          SMTP_PASS_SECRET: ${{ secrets.PROD_SMTP_PASS }}
          SMTP_FROM_SECRET: ${{ secrets.PROD_SMTP_FROM }}
          # Email verification / password reset rate-limit overrides (optional)
          EMAIL_VERIFICATION_COOLDOWN_SECONDS_SECRET: ${{ secrets.PROD_EMAIL_VERIFICATION_COOLDOWN_SECONDS }}
          EMAIL_VERIFICATION_DAILY_LIMIT_SECRET: ${{ secrets.PROD_EMAIL_VERIFICATION_DAILY_LIMIT }}
          PASSWORD_RESET_COOLDOWN_SECONDS_SECRET: ${{ secrets.PROD_PASSWORD_RESET_COOLDOWN_SECONDS }}
          PASSWORD_RESET_DAILY_LIMIT_SECRET: ${{ secrets.PROD_PASSWORD_RESET_DAILY_LIMIT }}
          # Token expiry overrides (optional)
          EMAIL_VERIFICATION_EXPIRES_IN_SECRET: ${{ secrets.PROD_EMAIL_VERIFICATION_EXPIRES_IN }}
          PASSWORD_RESET_EXPIRES_IN_SECRET: ${{ secrets.PROD_PASSWORD_RESET_EXPIRES_IN }}
          ADMIN_EMAIL_SECRET: ${{ secrets.PROD_ADMIN_EMAIL }}
          ADMIN_PASSWORD_SECRET: ${{ secrets.PROD_ADMIN_PASSWORD }}
        run: |
          set -euo pipefail

          # Resolve values with precedence: secret > default
          PORT="3000"
          DB_PORT="5432"
          POSTGRES_DB="${POSTGRES_DB_SECRET:-kotobamichi}"
          POSTGRES_USER="${POSTGRES_USER_SECRET:-postgres}"
          POSTGRES_PASSWORD="${POSTGRES_PASSWORD_SECRET:-}"
          JWT_SECRET="${JWT_SECRET_SECRET:-}"
          JWT_EXPIRES_IN="${JWT_EXPIRES_IN_SECRET:-7d}"
          ACCESS_TOKEN_EXPIRES_IN="${ACCESS_TOKEN_EXPIRES_IN_SECRET:-15m}"
          REFRESH_TOKEN_EXPIRES_IN="${REFRESH_TOKEN_EXPIRES_IN_SECRET:-7d}"
          COOKIE_SECURE="${COOKIE_SECURE_SECRET:-true}"
          COOKIE_SAMESITE="${COOKIE_SAMESITE_SECRET:-none}"
          CORS_ORIGIN="${CORS_ORIGIN_SECRET:-}"
          ADMIN_EMAIL="${ADMIN_EMAIL_SECRET:-}"
          ADMIN_PASSWORD="${ADMIN_PASSWORD_SECRET:-}"

          # DATABASE_URL may be provided directly, else fallback to constructed one (internal host 'db' on 5432)
          DATABASE_URL="${DATABASE_URL_SECRET:-}"
          COOKIE_SECRET="${COOKIE_SECRET_SECRET:-}"
          APP_URL="${APP_URL_SECRET:-http://localhost:3000}"
          # SMTP (optional)
          SMTP_HOST="${SMTP_HOST_SECRET:-}"
          SMTP_PORT="${SMTP_PORT_SECRET:-}"
          SMTP_SECURE="${SMTP_SECURE_SECRET:-}"
          SMTP_USER="${SMTP_USER_SECRET:-}"
          SMTP_PASS="${SMTP_PASS_SECRET:-}"
          SMTP_FROM="${SMTP_FROM_SECRET:-}"
          # Rate limit overrides (optional)
          EMAIL_VERIFICATION_COOLDOWN_SECONDS="${EMAIL_VERIFICATION_COOLDOWN_SECONDS_SECRET:-}"
          EMAIL_VERIFICATION_DAILY_LIMIT="${EMAIL_VERIFICATION_DAILY_LIMIT_SECRET:-}"
          PASSWORD_RESET_COOLDOWN_SECONDS="${PASSWORD_RESET_COOLDOWN_SECONDS_SECRET:-}"
          PASSWORD_RESET_DAILY_LIMIT="${PASSWORD_RESET_DAILY_LIMIT_SECRET:-}"
          # Token expirations (optional, fallback to sane defaults)
          EMAIL_VERIFICATION_EXPIRES_IN="${EMAIL_VERIFICATION_EXPIRES_IN_SECRET:-1d}"
          PASSWORD_RESET_EXPIRES_IN="${PASSWORD_RESET_EXPIRES_IN_SECRET:-1h}"

          # Validate required secrets
          if [ -z "$JWT_SECRET" ]; then
            echo "JWT_SECRET is required but missing (secrets.PROD_JWT_SECRET)." >&2
            exit 1
          fi

          if [ -z "$DATABASE_URL" ]; then
            if [ -z "$POSTGRES_PASSWORD" ]; then
              echo "Either provide secrets.PROD_DATABASE_URL or secrets.PROD_POSTGRES_PASSWORD to construct one." >&2
              exit 1
            fi
            # Note: if your password contains special characters (@, /, :), prefer providing PROD_DATABASE_URL directly.
            DATABASE_URL="postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}"
          fi

          # Validate APP_URL: must be provided and must not be the localhost default
          # This prevents accidental production deploys with unusable localhost links.
          if [ -z "$APP_URL" ] || [ "$APP_URL" = "http://localhost:3000" ]; then
            echo "APP_URL is required for production and must not be the localhost default (http://localhost:3000)." >&2
            echo "Please set secrets.PROD_APP_URL to your production URL (e.g. https://example.com)." >&2
            exit 1
          fi

          {
            echo "# Auto-generated by CI on $(date -u)"
            echo "NODE_ENV=production"
            echo "PORT=$PORT"
            echo "DB_PORT=$DB_PORT"
            echo "POSTGRES_DB=$POSTGRES_DB"
            echo "POSTGRES_USER=$POSTGRES_USER"
            # Do not echo POSTGRES_PASSWORD in logs; only write to file when available
            if [ -n "$POSTGRES_PASSWORD" ]; then echo "POSTGRES_PASSWORD=$POSTGRES_PASSWORD"; fi
            echo "DATABASE_URL=$DATABASE_URL"
            echo "JWT_SECRET=$JWT_SECRET"
            echo "JWT_EXPIRES_IN=$JWT_EXPIRES_IN"
            echo "ACCESS_TOKEN_EXPIRES_IN=$ACCESS_TOKEN_EXPIRES_IN"
            echo "REFRESH_TOKEN_EXPIRES_IN=$REFRESH_TOKEN_EXPIRES_IN"
            echo "COOKIE_SECURE=$COOKIE_SECURE"
            echo "COOKIE_SAMESITE=$COOKIE_SAMESITE"
            # Write non-sensitive values conditionally
            if [ -n "$COOKIE_SECRET" ]; then echo "COOKIE_SECRET=$COOKIE_SECRET"; fi
            echo "APP_URL=$APP_URL"
            if [ -n "$SMTP_HOST" ]; then echo "SMTP_HOST=$SMTP_HOST"; fi
            if [ -n "$SMTP_PORT" ]; then echo "SMTP_PORT=$SMTP_PORT"; fi
            if [ -n "$SMTP_SECURE" ]; then echo "SMTP_SECURE=$SMTP_SECURE"; fi
            if [ -n "$SMTP_USER" ]; then echo "SMTP_USER=$SMTP_USER"; fi
            if [ -n "$SMTP_PASS" ]; then echo "SMTP_PASS=$SMTP_PASS"; fi
            if [ -n "$SMTP_FROM" ]; then echo "SMTP_FROM=$SMTP_FROM"; fi
            # Rate-limits
            if [ -n "$EMAIL_VERIFICATION_COOLDOWN_SECONDS" ]; then echo "EMAIL_VERIFICATION_COOLDOWN_SECONDS=$EMAIL_VERIFICATION_COOLDOWN_SECONDS"; fi
            if [ -n "$EMAIL_VERIFICATION_DAILY_LIMIT" ]; then echo "EMAIL_VERIFICATION_DAILY_LIMIT=$EMAIL_VERIFICATION_DAILY_LIMIT"; fi
            if [ -n "$PASSWORD_RESET_COOLDOWN_SECONDS" ]; then echo "PASSWORD_RESET_COOLDOWN_SECONDS=$PASSWORD_RESET_COOLDOWN_SECONDS"; fi
            if [ -n "$PASSWORD_RESET_DAILY_LIMIT" ]; then echo "PASSWORD_RESET_DAILY_LIMIT=$PASSWORD_RESET_DAILY_LIMIT"; fi
            # Token expirations
            if [ -n "$EMAIL_VERIFICATION_EXPIRES_IN" ]; then echo "EMAIL_VERIFICATION_EXPIRES_IN=$EMAIL_VERIFICATION_EXPIRES_IN"; fi
            if [ -n "$PASSWORD_RESET_EXPIRES_IN" ]; then echo "PASSWORD_RESET_EXPIRES_IN=$PASSWORD_RESET_EXPIRES_IN"; fi
            if [ -n "$CORS_ORIGIN" ]; then echo "CORS_ORIGIN=$CORS_ORIGIN"; fi
            if [ -n "$ADMIN_EMAIL" ]; then echo "ADMIN_EMAIL=$ADMIN_EMAIL"; fi
            if [ -n "$ADMIN_PASSWORD" ]; then echo "ADMIN_PASSWORD=$ADMIN_PASSWORD"; fi
          } > .env

          # Outputs (non-sensitive only)
          echo "env_path=.env" >> "$GITHUB_OUTPUT"
          echo "port=$PORT" >> "$GITHUB_OUTPUT"
          echo "db_port=$DB_PORT" >> "$GITHUB_OUTPUT"
          echo "postgres_db=$POSTGRES_DB" >> "$GITHUB_OUTPUT"
          echo "postgres_user=$POSTGRES_USER" >> "$GITHUB_OUTPUT"
          echo "jwt_expires_in=$JWT_EXPIRES_IN" >> "$GITHUB_OUTPUT"
          if [ -n "$ADMIN_EMAIL" ]; then echo "admin_email=$ADMIN_EMAIL" >> "$GITHUB_OUTPUT"; fi

      - name: Ensure external Docker network exists
        shell: bash
        run: |
          set -euo pipefail
          docker network inspect kotobamichi-network >/dev/null 2>&1 || docker network create kotobamichi-network

      - name: Pull latest images
        shell: bash
        run: |
          set -euo pipefail
          docker compose -f docker-compose.prod.yml pull

      - name: Start/Update stack
        shell: bash
        run: |
          set -euo pipefail
          docker compose -f docker-compose.prod.yml up -d --remove-orphans

      - name: Show status
        shell: bash
        run: |
          docker compose -f docker-compose.prod.yml ps
          echo "--- Recent logs (app) ---"
          docker compose -f docker-compose.prod.yml logs --tail=120 app || true
          echo "--- Recent logs (migration) ---"
          docker compose -f docker-compose.prod.yml logs --tail=80 migration || true

      - name: Deployment summary
        shell: bash
        run: |
          echo "Deployment completed on $(hostname) at $(date -u)." >> "$GITHUB_STEP_SUMMARY"
          echo "PORT: ${{ steps.write-env.outputs.port }}" >> "$GITHUB_STEP_SUMMARY"
          echo "DB_PORT: ${{ steps.write-env.outputs.db_port }}" >> "$GITHUB_STEP_SUMMARY"
          echo "POSTGRES_DB: ${{ steps.write-env.outputs.postgres_db }}" >> "$GITHUB_STEP_SUMMARY"
          echo "POSTGRES_USER: ${{ steps.write-env.outputs.postgres_user }}" >> "$GITHUB_STEP_SUMMARY"
          echo "JWT_EXPIRES_IN: ${{ steps.write-env.outputs.jwt_expires_in }}" >> "$GITHUB_STEP_SUMMARY"
          if [ -n "${{ steps.write-env.outputs.admin_email }}" ]; then echo "ADMIN_EMAIL: ${{ steps.write-env.outputs.admin_email }}" >> "$GITHUB_STEP_SUMMARY"; fi
